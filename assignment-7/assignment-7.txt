[archie@swanstation cprogrm711]$ g++ ./include/Main.cpp ./assignment-7/TestProbe.cpp ./assignment-7/probe.cpp -L./lib -lUnitLite && ./a.out
4 tests, 0 failures, 0 errors

[archie@swanstation cprogrm711]$ g++ ./include/Main.cpp ./assignment-7/TestArray.cpp ./assignment-7/array.cpp -L./lib -lUnitLite && ./a.out
8 tests, 0 failures, 0 errors

7.2 Prompts:
 *   (Most recent prompt)
 *   + Describe why you chose to either use the default copy constructor and copy assignment or provide your own implementations.
 *   To allow for direct initialization and avoid ambiguity which results in compilation errors, the ctor is implemented.
 *   As for the copy ctor and assignment operator, explicit default was used for brevity.
 *
 *   (Originally copied prompts)
 *   + In this case, why is it better to write our own copy constructor and assignment operator
 *     rather than rely on the compiler generated ones?
 *   To use a unique_ptr and a copy constructor, the solution is more straight forward to define your
 *   own copy constructor. Similarly for assignment operators in a class with unique_ptr, not using the
 *   default constructor is the most obvious solution. By not using the default constructor avoiding
 *   future recompilation is also possible. Among many other considerations is personal
 *   preferences and aggregates.
 *   
 *   + In what situation might it be better to rely on the compiler generated copy constructor and assignment operators?
 *   When a class has no non-trivially default constructors and is trivially copyable (scalar types,
 *   trivial class types, arrays of trivial types, etc.) derived class constructors can automatically be generated.
 *   This saves time, or makes time to read Reddit at work.
